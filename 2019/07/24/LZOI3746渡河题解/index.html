<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="SkyDogMiao">
  <!-- Open Graph Data -->
  <meta property="og:title" content="渡河题解">
  <meta property="og:description" content="天狗成长路上的点点滴滴……">
  <meta property="og:site_name" content="天狗的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://SkyDogMiao.github.io">
  
    <link rel="alternate" href="/atom.xml" title="天狗的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="[object Object]">
  

  <!-- Site Title -->
  <title>天狗的博客</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/Head.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">渡河题解</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/SkyDogMiao">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:953438143@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
              <li>
                <a href="https://winjayran.github.io">
                  
                  友链LYJ
                  
                </a>
              </li>
            
              <li>
                <a href="https://presucc.github.io">
                  
                  友链CR
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By SkyDogMiao</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-07-24</span>
            <span class="time">11:33:02</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/信息/">信息</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/做题经历——知识点感悟与归纳/">#做题经历——知识点感悟与归纳</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>我们先来理解一下这道题的意思：</p>
<a id="more"></a>
<p>就是说我们要将n头牛渡到河，无非就是我们先渡其中几头过去，再回来，再渡几头过去</p>
<p>带着个空船走一波的时间为M，渡i头牛比渡i-1头牛要多花的时间是M_i</p>
<p>然后我们可以求出渡i头牛的时间</p>
<p>Num_i=M+M_1+M_2+……+M_i</p>
<p>上面这个式子应该没什么问题，用这个式子求出来的自然就是渡i头牛的时间。</p>
<p>我们现在要求至少花多少时间才能把所有牛渡到河对岸。</p>
<p>那么我们针对性地考虑一下方法的选择（虽然我做题时一眼看出正解）</p>
<p>1.贪心。</p>
<p>它说求最少，那我们不妨考虑一下贪心。</p>
<p>一种思路是考虑花Num_i时间渡i头牛的性价比，这样好像是能够让每一分每一秒“最值得”，貌似是没有错的。那么我们来尝试一下如何hack这个方法</p>
<p>假设n为ak+b，然后在1~n中，Num_k与k的性价比是最高的，那么我们的想法大概就是a次渡k头牛，然后再花最少的时间渡b头牛（假设我们已经求出来了），也就是k,k,k……,k,k,b，但是我们可能会有一个更优的方法，比如：k,k,k……k+b</p>
<p>这种情况就是k很值，但是b大得一匹。</p>
<p>所以这种贪心的正确性是不保证的，但是同学们可以尝试用这个方法骗很多（少）分（我也不知道能骗多少分）</p>
<p>然后我（们）就想不出别的贪心方法了（如果有同学能想出来可以尝试一下，但应该都会被hack）</p>
<p>我们考虑其他能保证正确性的方法。</p>
<p>2.DFS</p>
<p>有一种方法是绝对正确的，那就是爆搜！！</p>
<p>实际上就是所有把n拆成一堆正整数相加的所有情况中的最优情况。</p>
<p>这个方法就是枚举了所有的情况，百分百正确，但是时间复杂度非常恶劣。</p>
<p>时间复杂度的计算：</p>
<p>每次深搜就是枚举小于目前剩余的n，选最多n次，最坏的情况就是全部都选1，将n分成n份，所以最坏的时间复杂度为O(n!)，O(2500!)明显会爆，可能电脑都爆炸了。</p>
<p>DFS是会T掉的，但是它是保证正确的，所以我们不能就此放弃，要考虑对其的优化。</p>
<p>那么我们DFS实际上就是把n拆分成了x1+x2+x3+……+xk(k,x&lt;=n)</p>
<p>共k个数</p>
<p>然后我们把前面的x1+x2+x3+……+xk-1加起来，用一个s表示</p>
<p>那么n=s+xk</p>
<p>这不就是类似一个状态的转移吗？</p>
<p>既然有了这一状态的转移，那我们不妨尝试一下DP</p>
<p>老规矩，做DP，问什么设什么，我们设fi表示将i头牛渡过河的最少时间</p>
<p>那么fn就可以由fs和Num_xk转移过来了，而s也可以在n之前由ss和Num_xk-1转移过来</p>
<p>所以我们就继续往下想</p>
<p>状态如何转移？</p>
<p>假设目前要求fi，那该怎么求呢？</p>
<p>首先我们枚举fj(j&lt;i)，方便转移fi</p>
<p>那么i头牛的最短时间就是j头牛的最短时间加上渡i-j的时间，也就是Num_i-j</p>
<p>还要注意中间要渡回来，而将n头牛运完后又不用回来了</p>
<p>那么fi具体表示的应该就是将i头牛运到河对岸，并且船还在对岸的最短时间</p>
<p>特别地，f0表示的是一头牛都没有运的情况，那么船应该在原地</p>
<p>那么我们在转移的时候要特判一下j是否等于0,如果不等于0，那么说明船还在对岸，就要先开回来，也就是加上M，然后同样地转移</p>
<p>所以这道题就完啦！</p>
<p>时间复杂度计算：</p>
<p>枚举i要O(n)，枚举j要O(n)，所以总复杂度为O(n^2)</p>
<p>那么最后我们给一下丑丑的代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">const int N=2505;</span><br><span class="line">int f[N],n,Cost[N];//我这里的Cost[i]就是上面的Num_i </span><br><span class="line"></span><br><span class="line">inline int Read()&#123;</span><br><span class="line">    char ch;int f=1,x;</span><br><span class="line">    while((ch=getchar())&lt;&apos;0&apos;||ch&gt;&apos;9&apos;) if(ch==&apos;-&apos;) f=-1;x=ch^48;</span><br><span class="line">    while((ch=getchar())&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line">inline int Min(const int x,const int y)&#123;</span><br><span class="line">    return x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line">inline void Init()&#123;</span><br><span class="line">    memset(f,0x7f,sizeof(f));//初始化 </span><br><span class="line"></span><br><span class="line">    n=Read();Cost[0]=Read();f[0]=0;</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)</span><br><span class="line">        Cost[i]=Cost[i-1]+Read();//利用类似前缀和的方法 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">inline void Query()&#123;</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)&#123;//枚举运i头牛 </span><br><span class="line"></span><br><span class="line">        f[i]=Cost[i];//这里指一次性直接将i头牛运到河对岸</span><br><span class="line"></span><br><span class="line">        //这样的好处就是不用特判0了 </span><br><span class="line"></span><br><span class="line">        for(register int k=1;k&lt;i;k++)</span><br><span class="line">            f[i]=Min(f[i],f[k]+Cost[0]+Cost[i-k]);</span><br><span class="line">        //这里的k就是j，就是我们刚刚推的状态转移方程</span><br><span class="line">        //我再详细讲一下</span><br><span class="line">        //f[k]就是运k头牛，+Cost[0]就是要先回来</span><br><span class="line">        //Cost[i-k]就是从k转移到i要再运i-k头牛</span><br><span class="line">        //整条式子的意思就是</span><br><span class="line">        //f[i]   =f[k]   +Cost[0]+Cost[i-k]</span><br><span class="line">        //运i头牛=运k头牛+回来   +再运i-k头牛过去 </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,f[n]);//求运n头牛 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Query();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的人看到题一眼就看出是DP根本不用想那么多（膨胀一波就是我！）所以刷题很重要，大家要提高刷题量！</p>
<p>有问题的话欢迎提出！</p>
<p>每一个代码都要自己敲，请勿轻易复制粘贴题解的已有代码</p>
<p>thanks！</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>

